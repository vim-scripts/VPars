*vpars.txt*	VPars: Vim Parameter Substitution      Last Change: 2007-01-07

			      VPars User Manual~
				 Version 2.1~

		       Copyright (c) 2006 by Bernd Pol
			 <bernd.pol AT online DOT de>

This material may be distributed only subject to the terms and conditions set
forth in the Open Publication License, v1.0 or later (the latest version is
presently available at http://www.opencontent.org/openpub/).

To install VPars, see|vpars-install-and-customize|.

==============================================================================
CONTENTS                                              *vpars* *vpars-contents*

Although being conceptually simple does VPars bear a wealth of concepts which
account for this rather elaborate discussion.  You will basically find seven
chapters concentrating on the following issues:

|vpars-1|	What is Vpars?
		    A gentle introduction in the way VPars works.

|vpars-2|	Variable types
		    Discusses the syntactical structure of VPars variable
		    types and how to use it properly.  Deals as well with how
		    an order can be defined in which the variables will be
		    processed.

|vpars-3|	Variable substitution
		    Deals with details on how Vpars variables will get
		    substituted.  Especially the substitution cycle through
		    the so-called dedicated text block is treated in more
		    depth.

|vpars-4|	Beyond the substitution cycle
		    Stuff not immediately concerning the substitution of VPars
		    variables: jumping around the text block and outside as
		    well, pausing and resuming processing and last but not
		    least how to have a script substitute VPars variables in a
		    batch processing mode.

|vpars-5|	The VPars Programming Interface (API)
		    Contains all information necessary to use VPars from an
		    outside script: variables, functions, etc.  Except what
		    was discussed elsewhere above you will find information on
		    how to use VPars in GUI menu-based implementations.

|vpars-6|	Installing and customizing
		    VPars is highly configurable. This chapter describes how
		    to install VPars and how to tailor it to the user's needs.
		    Also find more information on VPars shortcut keys here.

|vpars-7|	Known problems
		    There is no software without problems and open wishes:
		    bugs and todos.

------------------------------------------------------------------------------
DETAILED CONTENTS						     *vpars-1*

|vpars-intro|			What is VPars?
|vpars-example| 		    An introductory example
|vpars-basic|			    Basic principles
|vpars-defininitions|		    Some definitions of terms
|vpars-text-block|			Dedicated text block
|vpars-label|				Variable label
|vpars-default|				Default value
|vpars-delete|				Deleting variables
|vpars-substitution-text|		Substitution (or replacement) text
								     *vpars-2*
|vpars-variables|		Variable types
|vpars-commons|			    Common structure of VPars variables
|vpars-delimiters|			Delimiters
|vpars-restrictions|			Restrictions
|vpars-cursor|			    The cursor mark
|vpars-simple-variables|	    Simple variables
|vpars-explicit-labels|		    Explicitely labeled variables
|vpars-alternatives|		    Providing alternative substitutions
|vpars-alternatives-example|		An example
|vpars-alternatives-syntax|		The syntax of VPars alternatives
|vpars-variables-order|		    Defining a variable sequence order
|vpars-variables-order-example|		An example
|vpars-variables-order-delay|		Delaying variables
|vpars-suppress-delays|			How to suppress a delay
								     *vpars-3*
|vpars-substitution|		Variable substitution
|vpars-substitution-simple|	    Simple variables
|vpars-substitution-explicit|	    Explicitely labeled variables
|vpars-substitution-alternative|    Selecting alternatives
|vpars-substitution-cycle|	    The substitution cycle
|vpars-start-functions|			How to call VPars
|vpars-modes|				Working modes
|vpars-substitution-block|		Dedicated text block
|vpars-substitution-delayed|		Delayed variables
|vpars-substitution-no-delay|		Escaping delay brackets
|vpars-programmed-variables|		Using programmed variables
								     *vpars-4*
|vpars-beyond-cycle|		Beyond the substitution cycle
|vpars-navigate-block|		    Navigating the text block
|vpars-atend|				The block end condition
|vpars-jump-end|			Jumping to the end of the text block
|vpars-jump-begin|			Jumping to the beginning of the text block
|vpars-show-block|			Showing the dedicated text block
|vpars-change-block|		    Prematurely Leaving the text block
|vpars-leave-temporarily|		Temporarily leaving the text block
|vpars-pause|				How to explicitly pause processing
|vpars-resume|				How to resume processing again
|vpars-leave-to-another|		Leaving to another text block
|vpars-invalidate-block|		Invalidating the dedicated text block
|vpars-batch|			    Batch processing a substitution list
|vpars-batch-example|			Example
|vpars-batch-syntax|			Syntax
								     *vpars-5*
|vpars-interface|		The VPars Programming Interface (API)
|vpars-inhibit|			    Inhibit loading the VPars Script
|vpars-globals|			    Global variables
|vpars-functions|		    Functions
|vpars-functions-init|			Initialization functions
|vpars-functions-menu|			Menu functions
|vpars-functions-process|		Processing functions
|vpars-functions-jump|			Block jump functions
|vpars-hooks|			    Pre and post processing hooks
|vpars-locals|			    Buffer local variables
|vpars-properties|			Current variable properties
|vpars-boundaries|			Text block boundaries
|vpars-other-buffer-locals|		Other buffer locals
								     *vpars-6*
|vpars-install-and-customize|	Installing and customizing
|vpars-installing|		    Installing VPars
|vpars-user-definitions|	    User Definitions
|vpars-key|			    Redefining the trigger key (default: <F3>)
|vpars-alternate-keys|		    Alternate shortcut keys
|vpars-include-menu|		    Including a VPars Menu
|vpars-skip-atend|		    Advancing over the block end
|vpars-verbose|			    Using verbose mode
								     *vpars-7*
|vpars-problems|		Known problems
|vpars-bugs|			    Bugs
|vpars-todos|			    Stuff left to be done

|vpars-thanks|			Thanks
|vpars-index|			Index

==============================================================================
WHAT IS VPARS							 *vpars-intro*

"VPars" literally means "Vim Parameter Substitution" and as such forms the
basis of yet another template manager. It allows to substitute certain
preformatted variables in a given text block either interactively or in batch
mode.

Basically it is simple: You sprinkle a portion of text with some kind of
variables, each delimited by "<| ...  |>" brackets, mark the start and end
lines of this text in some suitable fashion (e.g. by visually selecting this
text block with the "v", or "V"  and movement commands) and then repeatedly
press  the <F3> function key, enter some replacement text (or leave the
default intact), press <F3> again and so on until all this text portion has
been processed.

AN INTRODUCTORY EXAMPLE			 *vpars-intro-example* *vpars-example*

For example you may use some clever templates script to help in C programming,
which will insert some complete pre-fabricated statements automatically upon
pressing some shortcut key sequence.  The result for an "if" statement may
then look like. >

	if ( <|some condition|> ) {
	}

If your template script is really clever working, it will silently have marked
the beginning and end lines properly and put the cursor right after the
beginning "<|" variable delimiter, just before the "s" of "some condition".

Now, as the cursor position is crucial for the workings of VPars, let us
write a "#" sharp sign in its place: >

	if ( <|#some condition|> ) {
	}

Usually Vim will now even be in insert mode, then, so all you have to do now
is to enter the proper condition, say: >

	if ( <|VPars == SMART#some condition|> ) {
	}

and then press <F3>.  VPars will immediately replace the variable by what you
have typed in and put the cursor at the end of this statement: >

	if ( VPars == SMART ) {
	}#

Not very impressive? Well, let's look at a more elaborate piece.  Say, your
script has entered a template for the ubiquitous C "for" loop ("#" denotes the
cursor again): >

	for ( <|# i |> = <| 0 |>; <| i |> < <| n |>; <| i |>++ ) {
	    <|>;
	}

You decide to keep the "i" loop variable and immediately press <F3>.  Now,
this is what happens: >

	for ( i = <|# 0 |>; i < <| n |>; i++ ) {
	    <|>;
	}

Well, this is a real time saver, isn't it? VPars did replace each and every
<| i |> VPars variable by the default "i" symbol, just as wanted.  And then
it positioned the cursor to the next variable in the sequence, the loop
starting value, defaulting to "0".   This, on the other hand, is not to your
needs, so you typed in another value: >

	for ( i = <|99# 0 |>; i < <| n |>; i++ ) {
	    <|>;
	}

Press <F3>, the "<| 0 |>" variable vanishes, making place to the "99" you
wanted.  And the cursor will be put to the following "<| n |>" VPars variable,
denoting the loop end condition.  There you decided to use a predefined
constant value instead of the "n": >

	for ( i = 99; i < <|BIG_LOOP# n |>; i++ ) {
	    <|>;
	}

Another <F3> will get the loop conditions right, so you finally get: >

	for ( i = 99; i < BIG_LOOP; i++ ) {
	    #;
	}

See the cursor? It totally replaced the "<|>", ready for you to enter some
statements (yes, Vim is kept in insert mode, too).  You can do some simple
typing, or decide to leave this place alone and go on with outlining the basic
program structure.  So, another <F3> brings you to the end of this statement
template: >

	for ( i = 99; i < BIG_LOOP; i++ ) {
	    ;
	}#

and there the cursor remains at subsequent <F3> presses, unless you
explicitely replace it in the course of your editing session.

Let's sum this up:

------------------------------------------------------------------------------
BASIC PRINCIPLES			      *vpars-basic* *vpars-principles*

VPars usually works on a dedicated text block (see:|vpars-dedicated-text|),
whose boundaries have been marked by some block local variables
(see:|vpars-boundaries|).

Starting from the current cursor position in this dedicated text block, VPars
searches on command (usually after an <F3> keypress, or in answer to some
outside function call) for|vpars-variables|delimited by "<| ... |>".

If it finds one, the cursor is put right after the "<|" variable delimiter and
Vim will be switched to insert mode, ready to enter some text the user wants
to be substituted in place of this variable.  This can be almost anything,
even multiple lines, but the cursor must remain inside the "| ... |"
delimiters upon the next <F3> keypress.

This subsequent <F3> keypress commands VPars to investigate the text between
the left "<|" variable delimiter and the current cursor position.  If there is
any, it will replace the whole variable from the beginning "<|" up to the
ending "|>" delimiters.

This done, VPars searches all of the dedicated text block for any variable
with the same contents of the just replaced one in the moment it had been
encountered by VPars before the user did alter it.  I.e. if this variable
looked like "<|my VPars test|>", VPars now searches for another occurrences
of exactly this "<|my VPars test|>" variable and replaces anyone it finds by
the text the user had entered in the first place.  So, if for example the
initially found "<|my VPars test|>" had been replaced by "VPars is great!",
any other place, where a "<|my VPars test|>" was located will now read "VPars
is great!".  An example:

The text block before substitution ("#" again denotes the cursor position): >

	Dear John, <|#my VPars test|>  Just as I expected.
	It does	everything I want.  Everything!  <|my VPars test|>
	(Well, almost--but nevertheless, <|my VPars test|>)
	Tell <|the other person|> about it.

After the user entered the replacement text: >

	Dear John, <|VPars is great!#my VPars test|>  Just as I expected.
	It does	everything I want.  Everything!  <|my VPars test|>
	(Well, almost--but nevertheless, <|my VPars test|>)
	Tell <|the other person|> about it.

And then, in answer to the <F3> keypress: >

	Dear John, VPars is great!  Just as I expected.
	It does	everything I want.  Everything!  VPars is great!
	(Well, almost--but nevertheless, VPars is great!
	Tell <|#the other person|> about it.

This done, VPars searches for another variable, starting right after the
location, where the user had entered the replacement text.  And, if found
("<|the other person|>" in our example), everything starts over again.

But you need not type in anything, if the current variable contents suit your
needs.  Just press <F3> again without moving the cursor, and VPars will
just only remove the delimiters. In our example: >

	Dear John, VPars is great!  Just as I expected.
	It does	everything I want.  Everything!  VPars is great!
	(Well, almost--but nevertheless, VPars is great!
	Tell the other person about it.#

Once every variable in the dedicated text has been substituted, VPars will put
the cursor at the end of this text, and any subsequent <F3> keypress will do
nothing until another dedicated text block is to be worked on.

------------------------------------------------------------------------------
SOME DEFINITIONS OF TERMS		   *vpars-defininitions* *vpars-terms*

Every VPars variable bears a label, by which it is found, and a default value
to be used in case the user does not provide a replacement text.

More formally:
				     *vpars-dedicated-text* *vpars-text-block*
dedicated text block ~

	This is the text on which VPars usually works.  It is line-oriented,
	i.e. it exceeds from a line (marked by the buffer local variable
	b:StartInsert) to a given end line (marked by b:EndInsert).  These
	delimiting markers will usually be set by the script utilizing the
	VPars substitution mechanism, or by visually selecting a text block
	and the pressing <F3>.
	
	VPars processes this dedicated text repeatedly in turns or so-called
	processing cycles (see:|vpars-substitution-cycle|) until any VPars
	variable in there has been processed (see also:
	|vpars-delayed-variables|).

	Note: It is possible to have variables outside a dedicated text be
	      processed by VPars (see:|vpars-global-mode|).  This processing
	      will be strictly linear, however.

								 *vpars-label*
variable label ~

	This is the text initially found between the "<| ... >|" delimiters.
	Once found, VPars will remember this label, so the text can be altered
	without harm. You may even delete it.  This will cause all variables
	bearing this label be deleted, but VPars will still find all of them.

							       *vpars-default*
default value ~

	In simple variables, this is exactly the same text as the label, just
	what has been found between "<|" and the corresponding "|>".  This
	text will replace the variable, if on pressing <F3> the cursor was
	found immediately right of the "<|" delimiter.  VPars works this way,
	even if there had some text been entered. Whenever it encounters the
	cursor at the leading "<|", it will use the default value. That way,
	if you decide while typing some replacement, the default would suit
	your purposes better, you don't need to erase anything.  Just only put
	the cursor back to the variable start and press <F3>.

								*vpars-delete*
deleting variables~

	There is a slight exception to this rule:  In case you removed the
	default text altogether, so that the variable now looks "<||>", with
	the cursor in between the bars, <F3> will cause all variables bearing
	this label be deleted altogether.

						     *vpars-substitution-text*
substitution (or replacement) text ~

	This is the text VPars encounters between the "<|" left variable
	delimiter and the current cursor position, after <F3> had been
	pressed.  The cursor must however still be to the left of the "|>"
	right variable delimiter.  VPars uses this text to replace any
	occurrence of a variable bearing the same label as this one inside the
	dedicated text block.  Variables outside this dedicated text block, if
	any, will remain unaltered, however.

	There are almost no restrictions (see:|vpars-restrictions|) on the
	substitution text, except that bars must be escaped like this: "\|".
	There can even be multiple lines in such a replacement.

	  *vpars-substitute-multilines* *vpars-multiple-lines* *vpars-NL-mark*
	Note:

	- CAUTION:~
	  Be careful when substituting multiple lines for a variable or
	  entering such at the cursor position!

	  = Do not move the cursor away from the last substitution text
	    character before pressing <F3>.  Otherwise the block end position
	    might get computed (possibly extremely) false.

	  VPars has only limited knowledge of changes to the dedicated text
	  block.  It will assume the cursor at the end of the substitution
	  text in any case when you press <F3>, and re-adjust the text
	  boundaries according to that assumption only.

	- When substituting multiple lines, VPars will internally pack the
	  user input lines into one single intermediate string, where '<NL>'
	  marks represent the actual newlines inserted.  These '<NL>' marks
	  will show up in the b:VarSubst block local variable to facilitate
	  searching and replacing other equally labeled variables.  They will
	  be replaced by actual newlines afterwards, before the next variable
	  in sequence is searched.

	  An external script can use such '<NL>' marks in a postprocess
	  variable hook function (see:|vpars-post-substitution-hook|) to
	  insert a multiline string into the text which VPars will then
	  break down actually into multiple lines afterwards.

==============================================================================
VARIABLE TYPES				       *vpars-variables* *vpars-types*

COMMON STRUCTURE OF VPARS VARIABLES	     *vpars-commons* *vpars-structure*

Basically, each VPars variable is constructed after a simple scheme which
comes in several flavours:
>
	<| default-value-and-label |>
	<| default-value |: explicit-label :|>
	<| alternative-1 | ... | alternative-n |>
	<| alternative-1 | ... | alternative-n |: explicit-label :|>
>
When VPars searches for a variable, it will aways position the cursor before
("on") the first value character immediately right of the first delimiting
bar, switch to insert mode and wait for a substitution text entered by the
user.

Note:

- Due to the way VPars internally works (it always switches to normal mode
  before internal processing which will cause the cursor to step back one
  position from insert mode), the start position is a bit more loosely
  defined:  VPars will assume the cursor between the bracket and the bar of
  the left "<|" delimiter being actually on the first value character. Thus
  ("#" denoting the cursor)
>
	<#|my variable|>
<
  will be treated like:
>
	<|#my variable|>
<
  This is of importance because otherwise if VPars finds the cursor inside the
  delimiters, it will automativally reparse the variable to keep
  synchronization (and possible alterations of the variable) intact.


DELIMITERS						    *vpars-delimiters*

VPars variables will be distinguished from the surrounding text by a common
outer delimiter pair.  Additionally there may exist inner delimiters to
distinguish different variable types.  Currently each of these delimiters is
hard coded inside the script and may not be redifined.  This might change in a
later revision.

					     *vpars-<|* *vpars-left-delimiter*
<|	left outer delimiter ~

	Every VPars variable starts with this token.

					    *vpars-|>* *vpars-right-delimiter*
|>	right outer delimiter ~

	Every VPars variable ends with this token.

	Note: Both left and right other delimiters must be on the same line.

					*vpars-|:* *vpars-left-explicit-label*
|:	left explicit label delimiter ~

	This token separates an explicit label (|vpars-explicit-labels|) from
	the value part inside a VPars variable.  Any text from here up to the
	corresponding ":|>" constitutes the label by which this variable will
	be known to VPars.

				       *vpars-:|>* *vpars-right-explicit-label*
:|>	right explicit label delimiter ~

	This is the right outer VPars variable delimiter in case the variable
	bears an explicit label (|vpars-explicit-labels|).

	Note: The colon bears this delimiting function only if there is a
	      matching "|:" left explicit label delimiter.  Otherwise it will
	      become part of the value to the left of it: >

			<|my val|:my name:|>
				 default value = "my val"
				explicit label = ":my name:"

			<|my defaults:|>
				 default value = "my defaults:"
				 default label = "my defaults:"
~
				      *vpars-|* *vpars-alternatives-delimiter*
|	alternative value delimiter ~

	If found within the value part of a VPars variable, i.e. in between
	delimiting "<| ... |>" or "<| ... |:" pairs, VPars will count the
	(possibly empty) text strings to the left and the right of such a bar
	as alternative values (see: |vpars-alternatives|), his variable may
	only be replaced with.  Example: >

			<|text 1|text 2|text 3|>

				alternative value 1 = "text 1"
				alternative value 2 = "text 2"
				alternative value 3 = "text 3"

			The "|" bars between "text 1" and "text 2" as well as
			between "text 2" and "text 3" are alternative value
			delimiters.
~
	VPars will replace the variable by that text alternative the cursor is
	currently in when <F3> was pressed.

						    *vpars-empty-substitution*
	Note: There can be adjacent bars.  These denote empty substitutions,
	      which when selected  will cause the variable be deleted: >

	      		<||text 1|>
~
	      This variable will either be removed (cursor between "||" or
	      replaced by "text 1" (cursor anywhere in between "|text 1|").

RESTRICTIONS						  *vpars-restrictions*

Labels, default and replacement texts can be almost anything. There are only
few restrictions on VPars variables and substitution texts:

- No VPars variable may exceed a line. ~

  This means both "<|" and "|>" delimiters of a given VPars variable must be
  on the same line. This has several consequences:

  1. A script utilizing VPars must take care not to break a variable apart by
     restructuring actions as e.g. reformatting the recently inserted text
     before all VPars variables have been replaced.

  2. Alternatives are limited to short string sequences.  A clever script can
     however use some kind of markers as alternative substitutions and later
     process the inserted one by a hook function (see:|vpars-hooks|) to insert
     another perfect VPars variable in its place which will afterwards be
     processed in another cycle (see:|vpars-substitution-cycle|) through the
     dedicated text.

  Note:
  
  - It is possible for substitution texts to extend over several lines.
    
    CAUTION:~
    You must not prematurely move the cursor away from the end of this
    multiline text before pressing <F3>.  Otherwise VPars will get out of
    sync.  See |vpars-substitute-multilines| for more detail.

- Texts inside a VPars variable cannot contain VPars variables themselves.~

  This clearly applies to labels, but to default, alternative, and
  substitution texts as well.  Clever scripts can however post-process the
  substituted texts by a hook function (see:|vpars-hooks|) to insert another
  perfect VPars variables which will afterwards be processed through the
  dedicated text in another cycle (|vpars-substitution-cycle|).

  Note:

  - There is a possibility to partly work around this restriction using the
    concept of dot escaped delay brackets (see:|vpars-suppress-delays|).

    Assume a VPars variable being surrounded by another pair of brackets,
    separated form the variable proper by dots, like this:
>
	<.<|escaped delay variable|>.>
<
    Now replace the default value of this construct by something almost
    variable like, only missing the delimiting brackets, e.g.:
>
	|new variable|
<
    Then VPars will replace the inner, "<| ... |>" delimited, part and remove
    the dots as well, so you get:
>
	<|new variable|>
<
    Another full fledged VPars variable in place of the old construct. An
    outside script can use this behaviour to "program" the variables inside
    the dedicated text block.  Hence, we call this concept "programmed
    variables" (more:|vpars-programmed-variables|).

------------------------------------------------------------------------------
THE CURSOR MARK							*vpars-cursor*

This is the simplest type of a VPars variable:

	<|> ~

VPars will remove it completely on encounter and leave the cursor there.  Then
it switches to insert mode, ready to enter.

Note:

- It is possible for texts entered at such a VPars cursor position to extend
  over several lines.
  
  CAUTION:~
  You must not prematurely move the cursor away from the end of this
  multiline text before pressing <F3>.  Otherwise VPars will get out of
  sync.  See |vpars-substitute-multilines| for more detail.

------------------------------------------------------------------------------
SIMPLE VARIABLES				      *vpars-simple-variables*

Simple variables consist of some text, delimited by "<| ... |>".

	<|label and default value|> ~

The text between the bars denotes label and default substitution text alike
and can be anything, provided

- it does not exceed the line (i.e. both left and right delimiters must remain
  on the same line), and

- there are no other "<|" or "|>" variable delimiters included.

VPars will put the cursor immediately right of the left delimiter bar and
switch to insert mode.  Any text except "<|" or "|>" variable delimiters may
then be entered, even multiple lines.  VPars will upon the next <F3> keypress
consider any such sequence of characters between the left delimiter bar and
the cursor to be the substitution and replace everything starting with the
"<|" left delimiter up to the "|>" right delimiter by this substution text.

Note:
		*vpars-automatic-substitution* *vpars-replace-all-simple-vars*
- If working in between a dedicated text block (|vpars-text-block|), any other
  simple variable, bearing exactly the same "label and default value" which
  had been first encountered by VPars will be replaced as well.  If the simple
  variable was located outside such a dedicated text block however no other
  substitution will happen.

				*vpars-role-of-the-cursor* *vpars-cursor-role*
- Only the text between the left delimiter bar and the cursor counts.  VPars
  will remember the initially encountered "label and default value".  This may
  be deleted or changed in any way afterwards without harm (and without any
  consequences to substitution).

						  *vpars-default-substitution*
- To substitute the variable by its given default value, just leave the cursor
  immediately right of the left delimiting bar (# denotes the cursor): >

		<|#label and default value|>
~
  In this special case <F3> will replace the variable by exactly the default
  value it did encounter initially ("label and default value" in our example),
  even if it had been altered in the meantime.

		      *vpars-remove-simple-variable* *vpars-simple-var-delete*
- To remove this (and every equally labeled VPars variable in the dedicated
  text block) altogether, any text between the left and right delimiting bars
  must be deleted and the cursor remain between those bars before pressing
  <F3>: >
  		<|#|>
~
						  *vpars-cursor-in-delimiters*
- The behaviour if the cursor was put in between the "<|" or "|>" delimiting
  pairs (or immediately in front of the left "<|" one) before pressing <F3>
  currently is not very consistent.  Usually this (possibly altered) variable
  will simply be skipped and then be handled in the next turn
  (|vpars-substitution-cycle|).  But there may be irregular substitutions, so
  don't count on this behaviour for now.

- It is possible for substitution texts to extend over several lines.
 
  CAUTION:~
  You must not prematurely move the cursor away from the end of this multiline
  text before pressing <F3>.  Otherwise VPars will get out of sync.  See
  |vpars-substitute-multilines| for more detail.

------------------------------------------------------------------------------
EXPLICITELY LABELED VARIABLES			       *vpars-explicit-labels*

There are cases where the simple "label and default value" strategy of VPars
variables will not be enough.  Consider for example a list, where some items
may accept the same default value, but not simultaneously, i.e. you have to
decide for every such item in turn whether it will receive the default or an
explicitely enterend value.  To accomplish this there must be a way to
identify such a variable independently from other, similar ones.

VPars allows this by introducing an explicitely label a variable in a two
parts format such as:

	<|default value|:explicit label:|> ~

Whenever VPars encounters such a variable, it will remember two different
facts:

- the "default value", which behaves exactly like the one in a simple variable
  (|vpars-simple-variables|), and

- an ":explicit label:" by which it will identify any other variable to be
  replaced by the same substitution text (|vpars-substitution-text|).

Upon an <F3> keypress, Vpars will replace all of this variable from the "<|"
left delimiter to the "|>" right one by the text extending from the left
delimiting bar up to the cursor position, or by the "default value" if the
cursor was found immediately right of the first delimiting bar.  This is
exactly like the behaviour in a simple variable.

					 *vpars-precedence-of-explicit-labels*

The difference between simple and explicitely labeled VPars variables lies in
the way the VPars will treat the other variables in the dedicated text block
(|vpars-text-block|).  VPars will replace ANY variable bearing this ":explicit
label:" even if it features another default value or even is an alternative
selection (|vpars-alternatives|).

Effectively, explicite labels always have precedence over other means to
handle a VPars variable.  Usually this need not bother, but a clever script
might use this feature for additional flexibility by deliberately selecting
one of differently constructed VPars variables, all bearing the same explicit
label, in the first place.

Note:
						       *vpars-explicit-colons*
- The colons are part of the explicite label.  I.e. VPars will always look for
  ":explicite label:" instead of "explicite label" alone when searching for an
  explicitely labeled variable to replace.  A hook function (|vpars-hooks|) in
  a script which wants to pre- or postprocess variables must take this into
  account.
						      *vpars-explicit-reparse*
- If at an <F3> keypress the cursor is located in the explicit label part,
  VPars will assume this label was altered on purpose and will immediately
  reparse the variable.
  
  If for example the initially parsed variable ("#" denotes the
  current cursor position): >

  	<|#my value|:my var:|>
~
  when pressing <F3> will look like: >

	<|my value|:my extra# var:|>
~
  VPars will reparse this altered variable: >

  	<|#my value|:my extra var:|>
~
  and now consider it as being labeled ":my extra var:" instead of the
  previous ":my var:". This will also include an eventually altered label
  part: >

	<|my other value|:my extra# var:|>
~
  will result in this reparse: >

	<|#my other value|:my extra var:|>
~
  where the ":my extra var:" variable will be remembered as featuring the
  default value "my other value" instead of the previous "my value".

- It is possible for substitution texts to extend over several lines.
 
  CAUTION:~
  You must not prematurely move the cursor away from the end of this multiline
  text before pressing <F3>.  Otherwise VPars will get out of sync.  See
  |vpars-substitute-multilines| for more detail.

------------------------------------------------------------------------------
PROVIDING ALTERNATIVES					  *vpars-alternatives*

There are cases where the user should better be relieved from the need to
explicitely enter some value.  This will not only ease the user's tasks but
help to eliminate some other source of error.

AN EXAMPLE					  *vpars-alternatives-example*

Let us look for example at the versatile Doxygen (http://www.doxygen.org)
documentation generator.  It parses a program code (usually C++) for specially
formatted comments where it will build the documentation from.  For example
you can force it to classify a function parameter as being input, output or
input/output oriented by appending the Doxygen "\param" tag accordingly. >

	\param[in]
	\param[out]
	\param[inout]
~
or even have no such classification at all.  Now assume there is a template
script utilizing VPars to construct a Doxygen function header which beside
others will provide a list of parameter tags, each looking like this ("#",
again, denotes the current cursor position): >

	\param arg1 <|#|:arg1-description:|>
~
The user must provide an (optionally empty) description of the purposes of the
parameter named "arg1".  (Besides, we used an expliciteley labeled variable
here (|vpars-explicit-labels|) to allow an empty default value.)  Yet, this is
not completely satisfactory---the user should be forced to enter those "[in]",
"[out]", etc. "\param" modifiers as well.  One attempt could introduce another
variable like this >

	\param<|#[inout]|:arg1-mod:|> arg1 <||:arg1-description:|>
~
and let the user modify this default according to his needs.  But this is
unnecessarily error prone.  VPars provides a more secure way: >

	\param<|#|[in]|[out]|[inout]|> arg1 <||:arg1-description:|>
~
This new variable might look a bit confusing at first sight, but it really
does what we want.  It provides a series of alternative values, each separated
by a bar from the others.  In sequential order there are: >

	||		an empty value:         no param modifiers at all
	|[in]|		the "[in]" modifier:    an input only parameter
	|[out]|		the "[out]" modifier:   an output parameter
	|[inout]|	the "[inout]" modifier: an input/output parameter
~
The user now only needs to put the cursor somewhere into the alternative
value he/she wants and then press <F3>. VPars then does everything else.
This selection for example: >

	\param<||[in]|[o#ut]|[inout]|> arg1 <||:arg1-description:|>	
~
will result in the line: >

	\param[out] arg1 <|#|:arg1-description:|>	
~
ready to complete (or leave out) the description part.


THE SYNTAX OF VPARS ALTERNATIVES		   *vpars-alternatives-syntax*

VPars alternatives are syntactically like other VPars variables
(|vpars-simple-variables|, |vpars-explicit-labels|) but replace the default
value part with a list of alternative selections separated by bars:

	<|alt 1|alt 2| ... |alt n|> ~
or
	<|alt 1|alt 2| ... |alt n|:explicit label:|> ~

VPars will put the cursor immediately right right of the left delimiter bar and
switch to insert mode.  But in this case the user is not supposed to enter any
text.  All that needs to be done is to put the cursor on the alternative to be
selected and the press <F3>.

VPars will take all characters between the bars surrounding the cursor as
substitution string and replace the variable by this text.  The exact cursor
postition does not matter, any position from on the first alternative
character up to being on the right delimiting bar (respectively right after
the last alternative character) will count.

Note:
			  *vpars-alternatives-empty* *vpars-empty-alternative*
- There may be empty alternatives.  In this case two bars in the alternatives
  list must be immediately adjacent to each other: >

  	<||alt 1|>
~
  VPars will parse thes variable reaturing an empty alternative ("||") and the
  alternative text "alt 1").  If after pressing <F3> the cursor is found
  located between the adjacent bar ("#" denotes the cursor position): >

  	<|#|alt 1|>
~
   then the variable will be deleted altogether.

					     *vpars-alternatives-escaped-bars*
- To include some bar in an alternative, it must be escaped: "\|": >

  	<| up only | up\|down | down only |>
~
  will be parsed into 3 alternatives: " up only ", " up|down ", " down only ".

					    *vpars-alternatives-non-repeating*
- In its simple form without explicit label, an alternative will be processed
  only once.  No other alternatives variable will be automatically replaced,
  even if it has exactly the same format.  So, for example, if in ("#"
  denoting the current cursor position): >

  	alternative 1:<|# a | b | c |>and
	alternative 2:<| a | b | c |>selected..
~
  the first alternative VPars variable was replaced by " a ", this will have
  no effect on the other line: >

  	alternative 1: a and
	alternative 2:<|# a | b | c |>selected.
~
  The user may select whatever other variable is wanted, so the result might
  look like: >

  	alternative 1: a and
	alternative 2: c selected..
~
  To have other VPars alternatives variables be replaced as well, they must
  all bear the same explicit label as the currently parsed one.

						  *vpars-alternatives-altered*
- VPars will at an <F3> keypress check, whether the user did alter the
  alternatives list.  If so, it will assume this has been done on purpose and
  will immediately reparse the variable.  Hence if the variable initially
  parsed as ("#" denotes the cursor position): >

  	<|#alt 1|alt 2|>
~
  with the internally remembered alternatives "alt 1", and "alt 2", before
  pressing <F3> now looks like: >

	<|alt 1|AAA#|>
~
  VPars will reparse this immediately as: >

	<|#alt 1|AAA|>
~
  now remembering the variables "alt 1", and "AAA".

  This reparse will occur independently of which alternative the cursor
  currently was positioned at.

					     *vpars-alternatives-restrictions*
- The usual restrictions concerning variable length will hold with
  alternatives, too.  I.e. the variable cannot exceed the current line, both
  the "<|" starting as the "|>" must be on the same line.  This effectively
  reduces the number of possible alternatives (there should not be too many
  atlernatives anyway to be useful).  And it reduces the amount of text for
  any alternative.

  A clever script can however compensate for this limitation, postprocessing
  the substitution by a hook function (|vpars-hooks|).  The user may then e.g.
  select between some useful tags which the postprocessing hook function
  afterwards will substitute by another lengthy text before VPars will go on
  and find the next variable.

------------------------------------------------------------------------------
DEFINING A SEQUENCE ORDER FOR VARIABLES		       *vpars-variables-order*

Usually VPars will work the variables in the dedicated text block
(|vpars-text-block|) in strict sequential order, starting from the line marked
by b:StartInsert down to the line marked by b:EndInsert, thereby substituting
each variable it detects in turn.  Thus in >

	First variable in sequence is <|var 1|>,
	second variable in sequence <|var 2|>.

VPars will first handle <|var 1|> and then <|var 2|>.  But there often are
occasions where there are variables which cannot easily handled in such a
simple sequence.


AN EXAMPLE				       *vpars-variables-order-example*

Consider for example the following situation: >

	First variable in sequence is <|var 1|>,
	third variable in sequence is <|var 3|>,
	second variable in sequence is <|var 2|>.

We want first substitute <|var 1|>, then skip <|var 3|> and get replacement
for <|var 2|> and only after this was done let VPars handle the intermittent
<|var 3|>. But this won't work this way. There needs to be some means to
impose a specific order of processing on the variables.

This is accomplished in that VPars explicitely allows to skip a variable in
the current turn by enclosing it into an extra pair of "< ... >" delimiters.
Our example would then read: >

	First variable in sequence is <|var 1|>,
	third variable in sequence is <<|var 3|>>,
	second variable in sequence is <|var 2|>.

Now, using the default values, after substituting the first <|var 1|> variable
this would look like this (# denotes the current cursor position): >

	First variable in sequence is var 1,
	third variable in sequence is <|var 3|>,
	second variable in sequence is <|#var 2|>.

See what happened?  VPars did replace <|var 1|> by its default value, then
searched for the next "<|" variable start delimiter.  It found "<|var 3|>" and
noted that it was surrounded by an extra pair of "< ... >" brackets.
Therefore this variable was not deemed for substitution yet, but only the
outer "< ... >" brackets pair removed.  This done, VPars searched for the next
variable in this dedicated text block and found <|var 2|> where it now waits
for a substitution command.

Using the default value again we get this after pressing <F3>: >

	First variable in sequence is var 1,
	third variable in sequence is <|#var 3|>,
	second variable in sequence is var 2.

VPars did replace <|var 2|> and tried to find another "<|" delimiter following
this in the dedicated text block.  As there was none, it went back to the
start of this dedicated text block and tried again, this time finding the
<|var 3|> variable left over from the previous turn.  Now as there were no
more additional outer "< ... >" brackets found, <|var 3|> is about to be
replaced.

Using the default value once again, we got this situation: >

	First variable in sequence is var 1,
	third variable in sequence is var 3,
	second variable in sequence is var 2.#

Which means, VPars did replace <|var 3|> as wanted and tried to find another
"<|" delimiter.  There was none in sequence, so it took even another turn
through the dedicated text block, this time finding none at all.  So it noted
this dedicated text block as being completely processed and put the cursor at
its very end, there waiting for the user to proceed with the work as needed.


DELAYING VARIABLES    *vpars-delaying-variables* *vpars-variables-order-delay*

The key to all this is that VPars repeatedly works any dedicated text block
(|vpars-text-block|) in turns until there are no more VPars variables left.
In each turn one level of "< ... >" delimiters of any VPars variable
encountered will effectively be removed.  If there are any such delimiter
brackets left, this variable will be skipped, otherwise it will be processed
for substitution.

Such delaying of variables within a turn allows to define an order in which
the variables inside a dedicated text block will be processed. More formally:

	delay level 0:	      <| ... |> ~
	delay level 1:	     <<| ... |>> ~
	... ~
	delay level n:	  <...<| ... |>...> ~
	delay level n+1: <<...<| ... |>...>> ~

Note:

- There is no limit on delay levels possible, provided the variable including
  all surrounding brackets completely fits within the curent line.

- Delaying variables outside a dedicated text block is only of limited value.
  Such variables will have their outer brackets removed when encountered, but
  there will be no automatic repeated processing.

- Delayed variables do not count in automatic substitution within the current
  turn.  I.e. if there are several equally labeled variables in the dedicated
  text block, only those on delay level 0 will be replaced together.  Delayed
  ones, even if explicitely labeled, will always be skipped.

==============================================================================
HOW TO SUPPRESS A DELAY	      *vpars-suppress-delays* *vpars-delay-escape-dot*

While the mechanism to delay a VPars variable is simple and elegant, there are
occasions where one needs a slight notation change.  Consider this Perl
fragment:
>
	while (<<|file handle|>>)
	{
	}
<
Now, after replacing the <|file handle|> variable by, say, "my_file", the
statement actually should look like:
>
	while (<my_file>)
	{
	}
<
But this does not work. VPars will assume the <<|file handle|>> being delayed
and finally will end up with this:
>
	while (my_file)
	{
	}
<
To solve situations like this, VPars allows to suppress the delay meaning of a
<...> bracket pair by placing so-called "delay escape dots" around the VPars
variable.  With these, our example will look like:
>
	while (<.<|file handle|>.>)
	{
	}
<
If VPars detects such a "<.<|" or "|>.>" delimiter sequence, it will silently
remove the escape dot after actually having replaced the variable.  Thus our
example will exectly work as expected and produce:
>
	while (<my_file>)
	{
	}
<
And what if you really want to end up with a situation like this:
>
	while (<.my_file.>)
	{
	}
<
Well, in this case you will have to escape the escape dot itself:
>
	while (<..<|file handle|>..>)
	{
	}
<

==============================================================================
VARIABLE SUBSTITUTION					  *vpars-substitution*

Details on how VPars will replace a variable by its substition text were
already given in the above discussion of the various VPars variable types
(|vpars-variables|). To sum it up:

SIMPLE VARIABLES				   *vpars-substitution-simple*

<|label and default value|> ~

Label:			"label and default value"
Default value:		"label and default value"
			Used as substitution text if the cursor was
			found immediately right to the "<|" starting
			delimiter.
Substitution text:	All characters between the "<|" starting
			delimiter and the current cursor position.

EXPLICITELY LABELED VARIABLES			 *vpars-substitution-explicit*

<|default value|:explicit label:|> ~

Label:			":explicit label:"
Default value:		"Default value"
			Can be empty:	"<||:explicit label:|>"
			Used as substitution text if the cursor was
			found immediately right to the "<|" starting
			delimiter.
Substitution text:	All characters between the "<|" starting
			delimiter and the current cursor position.

SELECTING ALTERNATIVES			      *vpars-substitution-alternative*

<|alt 1|alt 2| ... |alt n|> ~
<|alt 1|alt 2| ... |alt n|:explicit label:|> ~

Label:			none or ":explicit label:"
Default value:		none (actually)
			(In fact "alt 1", because the cursor is put there when
			the variable is encounered.)
Substitution text:	All characters between the bars surrounding the
			current cursor position.
			Can be empty:	"||"
			The alternatives list ends at "|>", or "|:" if an
			explicit label exists.

------------------------------------------------------------------------------
THE SUBSTITUTION CYCLE				    *vpars-substitution-cycle*

Vparse basically works in one of two modes depending on whether a dedicated
text block is being processed or VPars is called outside of such a block.


HOW TO CALL VPARS				       *vpars-start-functions*

Pressing the <F3> next variable key causes a call to the VPars_RepJump()
function in normal or insert mode to accomplish any pending substitution of
the currently processed variable and the going on to search for another one.
In case a text block had been visually selected, <F3> will cause the
VPars_RepJumpBlock() function be called, which sets up this block for
processing and then calls Vpars_RepJump() in turn to accomplish the real work.

An external script could take the same route, but there is a shorter way:

- Call
>
  	VPars_Run( firstLine, lastLine )
<
  where <firstLine> and <lastLine> denote the boundary lines of the new
  dedicated text block.

Otherwise the script can call these VPars functions directly: 

- Set up a dedicated text block by defining the b:StartInsert and b:EndInsert
  lines, enabling processing by setting b:AtEndInsert to 0 and then calling
  VPars_RepJump(0).

- Or visually select a text block by some suitable means and then call
  VPars_RepJumpBlock().  As a side effect this will ensure that all buffer
  local variables used for substitution processing will initially be cleared
  before the VPars_RepJump() call.

- Once the dedicated text block has been set up, any subsequent call should go
  to VPars_RepJump(0).

Additionally, there is a simplified interface available which relieves the
calling script of some burden:

- Initially call VPars_Run( firstLine, lastLine ), where <firstLine> will
  b:StartInsert, and <lastLine> cause b:EndInsert be set.  Like
  VPars_RepJumpBlock() this will clear b:AtEndInsert and reset the internal
  buffer local processing variables prior to calling VPars_RepJump().

  Additionally some validity checks will be performed and the user optionally
  be warned in case the boundaries were not set up properly.

- Subsequently call Vpars_Run( -1, 0 ).  This will check the boundaries and
  then call VPars_RepJump() as usual.

Note:

- VPars_Run() can use already available b:StartInsert or b:EndInsert line
  settings when it is called with <firstLine> and/or <endLine> set to 0.  This
  can be used to change the block boundaries on the fly in special processing
  situations.

- By calling VPars_Run() when b:AtEndInsert does not yet exist, VPars can at
  any time be forced to reset the internal buffer local processing variables
  and thus reparse the current variable. (Take care to reposition the cursor
  in front of the "<|" starting delimiter of this variable.)

  This can be accomplished through explicitely removing b:AtEndInsert by
>
  	:unlet b:AtEndInsert
<
  prior to the VPars_Run() call.


WORKING MODES							 *vpars-modes*
							   *vpars-normal-mode*
- normal mode:~
  Repeating turns through a dedicated text block (|vpars-text-block|)
							   *vpars-global-mode*
- global mode:~
  Straight ahead search outside of a dedicated text block.

The substitution cycle in repeating turns mode is one of the basic strengths
of VPars.  It was introduced in the |vpars-variables-order-example|
chapter.  In short:


DEDICATED TEXT BLOCK				    *vpars-substitution-block*

This consists of several text lines whose boundary lines are kept in two
buffer local variables:

b:StartInsert ~
	Holds the line number where the dedicated text block starts.

b:EndInsert ~
	Holds the line number where the dedicated text block ends.

Note:

- These have to be externally defined before using VPars in repeating turns
  mode, except when calling VPars_RepJumpBlock() (see:|vpars-functions|).

- The "Insert" phrase in these names is historical.  It corresponds to the
  originally intended VPars use---processing most recently inserted code
  templates.


DELAYED VARIABLES				  *vpars-substitution-delayed*

In both modes VPars will conceptually process any variable it finds according
to the number of "< ... >" brackets surrounding it.

- The outermost "< ... >" brackets will be removed.
- If there are any "< ... >" surrounding bracket pairs left, the variable will
  be skipped and the next one in sequence searched.
- Otherwise the variable will be processed according to the usual substitution
  rules.

More formally, the processing of any VPars variable in the current normal mode
turn can be delayed by adding another level of "< ... >" brackets:

immediade processing:~

	delay level 0:	      <| ... |> ~

delayed:~

	delay level 1:	     <<| ... |>> ~
	... ~
	delay level n:	  <...<| ... |>...> ~
	delay level n+1: <<...<| ... |>...>> ~

See|vpars-delaying-variables|for more detail about delayed variable
processing in both VPars working modes.


ESCAPING DELAY BRACKETS				 *vpars-substitution-no-delay*

It is possible to escape from the delay meaning of a "< ... >" brackets pair
through the use of delay escape dots.

escaped delay:~

	<.<| ... |>.>~

If found, VPars will in the course of a variable substitution replace the dot
between the "<|" starting delimiter and an immediately adjacent "<" bracket.
Likewise will the dot between a "|>" ending delimiter and an immediately
adjacent ">" bracket be removed.  Thus:
>
	<.<|my value|>.>

will e.g. become:
>
	<my value>

If such a dot shall remain in place after substitution, it must be escaped
again, using two dots between the brackets:

escaped delay dots:~

	<..<| ... |>..>~

The construct:
>
	<..<|my value|>..>

might then become:
>
	<.my value.>

Note:

- This mechanism does work only if the brackets are immediately adjacent to
  the escape delay dot.  All other cases will be left alone. Thus:
  >
  	<. <|my value|>. >
<
  will become:
>
	<. my value. >
<
  (There will be extra characters -- spaces in this case -- around the dots.)

- The Vpars variable inside escape dots may however be delayed as usual, i.e.
  the following contruct is valid: >

  	<.<<<|my value|>>>.>
<
- Although it is more aesthetically pleasing to have the variable delay
  escaped by a pair of dots, this is not really necessary.  A single escape
  delay dot will suffice to break the delay meaning of some outer brackets.
  Thus the following will eventually all result in "<my value>": >

  	<.<|my value|>.>
	<.<|my value|>>
	<<|my value|>.>


USING PROGRAMMED VARIABLES			  *vpars-programmed-variables*

The dot notation to escape the delay meaning of outer bracket pairs opens way
to "program" VPars variables in some limited way, i.e. to have a script
replace a variable by another one.  That way it is possible to work around on
of the most basic |vpars-restrictions|, namely that texts inside a VPars
variable cannot contain VPars variables themselves.

The principle sounds simple: Just replace a variable inside a dot escaped
bracket pair by a "variable proper", i.e. a full fledged VPars variable with
the delimiting brackets removed:

If you for example a script substitutes the "replace this" label of the
following delay escaped VPars variable:
>
	<.<|replace this|>.>
<
by, say, "|my new variable|", the dedicated text will afterwards contain this
other VPars variable:
>
	<|my new variable|>
>
which will be processed in the next substition cycle through the dedicated
text block.

Note:

- Because VPars does not change anything outside the escaped brackets, it is
  possible to have the programmed variable delayed as well:
>
	<<.<|replace this|>.>>
<
  might thus become:
>
	<<|my new variable|>>
<
- Using the same mechanism it is possible to use several "levels" of
  programmed VPars variables.  Just surround them by another dot escaped
  bracket pairs. Example:
>
	<.<.<|replace this|>.>.>
<
  might thus become:
>
	<.<|my new variable|>.>
<
  which eventually will result in something like this:
>
	<|the final variable|>
<
==============================================================================
BEYOND THE SUBSTITUTION CYCLE				  *vpars-beyond-cycle*

------------------------------------------------------------------------------
THE BLOCK END CONDITION		     *vpars-block-end-condition* *vpars-atend*

If in the current normal mode processing turn no more VPars variables were
detected in the dedicated text block, this condition will be remembered in a
block local variable:

b:AtEndInsert~
	 1 if the end of the text block has been reached
	-1 if the block was left for some unknown cause
	 0 if still processing

By default, VPars will remain there even on successive <F3> keypresses.
Processing will proceed only if the cursor was explicitely moved out of the
block limits (or the block limits were reset by some external skript).

This behaviour may be overridden by explicitely setting this global variable:

g:VPars_SkipBlockend~
	If non-zero causes <F3> to automatically search beyond the text block
 	end if no more variables are in there.
 	Defaults to 0, which causes the cursor to stop at the block end.

------------------------------------------------------------------------------
JUMPING TO THE BEGINNING OF THE TEXT BLOCK		    *vpars-jump-begin*

The effect of prematurely jumping to the end of the dedicated text block can
be undone by another VPars function: >

	VPars_JumpBegin()
		This puts the cursor at the beginning of the currently defined
		dedicated text block and resets b:AtEndInsert, thus
		re-enabling subsequent VPars variables searches.

This function is by default bound to the >
	,jb 
shortcut.  This mapping can be redefined, see|vpars-shortcut-keys|.

Besides undoing the search lock set up by a premature block end jump there are
other benefits in prematurely jumping to the text block start.  One main
effect is in that it allows the user or another script to somewhat circumvent
the given variables processing order by simply forcing another scan before the
block end had been reached.

------------------------------------------------------------------------------

JUMPING TO THE END OF THE TEXT BLOCK			      *vpars-jump-end*

There are occasions where one would want to skip the processing of the VPars
variables in the dedicated text block altogether.  VPars provides a function
to do so: >

	VPars_JumpEnd()
		Causes the cursor be put at the end of the currently defined
		dedicated text block (the end of the b:EndInsert line) and
		sets b:AtEndInsert to 1, thus disabling any processing while
		keeping the b:StartInsert and b:EndInsert boundaries intact.

This function is by default bound to the >
	,je 
shortcut.  This mapping can be redefined, see|vpars-shortcut-keys|.

Jumping prematurely to the end of the most recently inserted text block would
i.e. allow a template script to chain different text blocks together and have
them processed afterwards in one single piece.

------------------------------------------------------------------------------
SHOWING THE DEDICATED TEXT BLOCK			    *vpars-show-block*

Visually selects the lines between b:StartInsert and b:EndInsert, thus making
the current dedicated text block visible.

This function is by default bound to the >
	',jo'
shortcut.  This mapping can be redefined, see|vpars-shortcut-keys|.

Note:

- VPars remembers the current location before visually selecting the text
  block.  To continue processing the variables, simply press <F3> again.

------------------------------------------------------------------------------
PREMATURELY LEAVING THE TEXT BLOCK			  *vpars-change-block*

The normal way VPars assumes about processing variables is that the user
repeatedly cycles through the dedicated text block until there is none left
over unprocessed (see the "The block end condition" section:|vpars-atend|).
It will then by default pause at the end of the current dedicated text block
until the cursor had been deliberately moved away to some outside position in
which case VPars will forget everything it knows about this old dedicated text
block and start over again.

There are however situations where the current dedicated text block would be
left prematurely.  VPars tries to cope with two standard cases of such
premature block leaves:

- The user wants to change something at another position in the text and later
  return to the dedicated text block and continue with the variable
  substitution work.

- Processing the current block will be ceased in favour of another dedicated
  text block to process the VPars variables located in there.


TEMPORARILY LEAVING THE TEXT BLOCK		     *vpars-leave-temporarily*

Each time <F3> had been pressed (or the VPars_RepJump() had been called by
some script) VPars checks whether the cursor is still inside the current
dedicated text block.  If it detects an outside position while the
b:StartInsert and b:EndInsert boundaries still being unchanged, it puts
the dedicated text block in some kind of a wait state.  This wait state is
flagged by setting b:AtEndInsert to -1 (|vpars-atend|) and causes VPars to
ignore all subsequent <F3> keypresses or calls to VPars_RepJump() until work
in the dedicated text block was explicitely resumed again (|vpars-resume|).


HOW TO EXPLICITLY PAUSE PROCESSING				 *vpars-pause*

There are cases where it will not suffice moving the cursor away to put VPars
into such a wait state.  Thus it is possible to explicitly force VPars to
pause processing.  There are three ways to accomplish this:

- Call the VPars_Pause() function (see|vpars-processing-functions|).

- Use the "jp" shortcut function (see|vpars-alternate-keys|).  This will call
  VPars_Pause().

- Use the "pause processing" VPars GUI menu entry (|vpars-menu-functions|).
  This will call VPars_Pause().  Such a menu will however only be available on
  demand either through a call to VPars_Menu() from the command line or--more
  often--after the VPars_SetupMenu function had been called from another
  script.

  Although to be used sparingly in a usual Vim environment, such a VPars menu
  has the additional benefit that the "pause processing" entry will be
  available only when there is a dedicted text block actually be processed,
  mainly thought as another benefit of the casual user.

Note:

- When entering the pause state, VPars will surround the current dedicated
  text block with a set of special marker variables:
>
	<|:0|>	will be inserted at the text block beginning
	<|0:|>	will be inserted at the text block end
<
  This is done in order to keep track of text changes, i.e. adding or deleting
  lines, before or inside the dedicated text block.  The markers help VPars to
  adjust the buffer local line variables properly as soon as the processing is
  resumed.


HOW TO RESUME PROCESSING AGAIN					*vpars-resume*

After pausing either by a call to Vpars_Pause(), jumping to the block end or
moving the cursor away from the currently processed block, processing can be
resumed at the most recently parsed variable position in either of the
following ways:

- Reposition the cursor manually or from another script to where the
  VPars loop shall be resumed, reset b:AtEndInsert to 0 and call
  VPars_RepJump() from a script or respectively press <F3>.

- Call the VPars_Resume() function (see|vpars-processing-functions|).

- Use the "jr" shortcut function (see|vpars-alternate-keys|).  This will call
  VPars_Resume().

- Use the "resume processing" VPars GUI menu entry (|vpars-menu-functions|).
  This will call VPars_Resume().  Such a menu will however only be available
  on demand either through a call to VPars_Menu() from the command line
  or--more often--after the VPars_SetupMenu function had been called from
  another script.

  Although to be used sparingly in a usual Vim environment, such a VPars menu
  has the additional benefit that the "resumee processing" entry will be
  available only when the processing actually had been paused, mainly thought
  as another benefit of the casual user.

Note:

- VPars will remove the special
>
	<|:0|> and <|0:|> markers around the dedicated text block
<
  again which were inserted by the pause processing function (|vpars-pause|).

- In case no such markers were found by the VPars_Resume() function, VPars
  will try to resume processing at the last variable location it knows of.
  This could fail in some circumstances, however, in which case the cursor
  should be explicitely repositioned before the next <F3> keypress.


LEAVING TO ANOTHER TEXT BLOCK			      *vpars-leave-to-another*

If VPars in response to an <F3> keypress or VPars_RepJump() call detects the
cursor between another pair of b:StartInsert, b:EndInsert lines, it will
immediately forget everything about previously parsed variables and start
looping this new dedicated text block.

Note:

- If for any reason such an immediate variables processing is not desired, the
  b:AtEndInsert flag must be set to 1 or -1 together with the b:StartInsert or
  b:EndInsert redefinition before calling VPars_RepJump().  This will cause
  VPars to recognize the new block but suppress processing any variables in
  there until this was explicitely enabled by b:AtEndInsert set to 0.


INVALIDATING THE DEDICATED TEXT BLOCK		      *vpars-invalidate-block*

Although VPars tries to automatically handle premature leaves, not all such
cases can be easily detected.  The problem is that although there may have
been new b:StartInsert, b:EndInsert and b:AtEndInsert boundary markers set up,
some internal buffer local variables will signal that there was work to do in
the more recent, prematurely left dedicated text block.  This may put VPars
out of sync, making it unable to process the new text block properly.

To handle such situations, a means to completely invalidate the old dedicated
text block before attempting to set up a new one was provided.  This is done
by the VPars_InvalidateBlock() (see|vpars-init-functions|). It resets the
b:StartInsert, b:EndInsert, and b:AtEndInsert boundary markers as well as the
buffer local variables, thus making the current dedicated text block
completely invalid.

This function is by default bound to the >
	',ji'
shortcut.  This mapping can be redefined, see|vpars-shortcut-keys|.

Note:

- Invalidating the current dedicated text block míght be necessary whenever
  one wants to process another dedicated text block before the end of the
  current block has been reached.  This makes sure the buffer local state
  variables are properly reset.

- Oterwise be careful using this function. It's effects cannot be undone,
  except by explicitely reselecting the block.

------------------------------------------------------------------------------
BATCH PROCESSING A SUBSTITUTION LIST    *vpars-batch* *vpars-substitution-list*

VPars mainly concentrates on interactive variable substitution.  While
undoubtedly useful this does not suffice as a basis for e.g. a really
practicable template application.


EXAMPLE							  *vpars-batch-example*

Assume you want to inform some folks about your VPars experiences.  To do so
you want to utilize VPars with some template like this: >

					<|date|>
	Dear <||Mr.|Mrs.|:sex:|><|name|>
	do you know about<|value|> VPars?
	Yours,

Of course this could be easily processed by VPars through repeated <F3>
keypresses.  But assume further there is some data base containing for
instance: >

	"Mr.","Fatty McDull","exceptional"
	"","Bill","very useful"

Wouldn't it be useful to have this data automatically processed?

There is an easy way in VParse to accomplish this.  Some template script might
read a line from this data base, load the template into vim, mark the borders
in b:StartInsert and b:EndInsert and then call the VPars_RepList() function
like this ("\" is the Vim line continuation symbol): >

	:call VPars_RepList( [["date", "May 3, 2006"],
			   \  [":sex:","Mr. "],
			   \  ["name","Fatty McDull"],
			   \  ["value"," exceptional"]] )

to automatically produce this letter: >


					May 3, 2006
	Dear Mr. Fatty McDull
	do you know about exceptional VPars?
	Yours,

Or: >

	:call VPars_RepList( [["date", "May 3, 2006"],
			   \  [":sex:",""],
			   \  ["name","Bill"],
			   \  ["value",""]] )

will result in: >

					May 3, 2006
	Dear Bill
	do you know about VPars?
	Yours,


SYNTAX							  *vpars-batch-syntax*

The VPars_RepList() function (for "replace list") provides some basic batch
processing facilities.  It can be called from another script using this
syntax (leaving out line continuation symbols):

	VPars_RepList( [["label 1", "replacement 1"], ~
			["label 2", "replacement 2"], ~
			... ~
			["label n", "replacement n"]] ) ~

Called on a dedicated text block (|vpars-text-block|) this will replace any
variable labeled "label 1" by "replacement 1", then "label 2" by "replacement
2" and so on until "label n", which will be replaced by "replacement n".

Note:

- The VPars_RepList() function requires a dedicated text block.  I.e. the
  calling script must ensure valid b:StartInsert and b:EndInsert delimiters
  set prior to the call.

- No action if the block delimiter marks b:StartInsert and b:EndInsert do not
  exist or were not properly initialized yet.

- If an explicetely labeled variable (|vpars-explicit-labels|) shall be
  processed, the surrounding colons must be included in the label part (as
  e.g. ":sex:" in the above examples).

- Replacement occures just like in interactive mode.  This means in
  particular, pre and post-processing hook functions (|vpars-hooks|), if
  existing, will be regularly called.

- After batch processing the listed VPars variables, any remaining variables
  may be interactively processed as usual by calling the VPars_RepJump()
  function (see:|vpars-functions|) and then repeatedly using the <F3>
  continuation key.

==============================================================================
THE VPARS INTERFACE				 *vpars-api* *vpars-interface*

VPars can be used strictly interactive by selecting the dedicated text block
(|vpars-text-block|) and then repeatedly stepping through the variables in
there, using the "next variable" key <F3>.

On the other hand, to access the VPars functionality from other Vim scripts,
VPars provides the following application programming interface (API).

|vpars-globals|		Global variables
|vpars-functions|	Functions
|vpars-hooks|		Pre and post processing hooks
|vpars-locals|		Block local variables

------------------------------------------------------------------------------
INHIBIT LOADING THE VPARS SCRIPT			       *vpars-inhibit*

VPars checks the
>
	g:vpars_vim
<
variable for existence to prohibit duplicate loading.  If you do not want to
have VPars script loaded in any case, define g:vpars_vim in your startup
script (e.g. in the $HOME/.vimrc script or equivalent).

Note:
- You should additionally signal other scripts which want to make use of VPars
  functions, that VPars will be currently unavailable by explicitely setting the
  g:vpars_vim value to zero:
>
	:let g:vpars_vim=0

------------------------------------------------------------------------------
GLOBAL VARIABLES	*vpars-globals*

g:vpars_vim~
	Prevents duplicate loading.
	Holds the version number if existent: maor version number times 100
	plus minor version number.
	To inhibit loading VPars set g:vpars_vim to zero in your startup
	script (e.g. ~/.vimrc).  This value signals other scripts that VPars
	currently will be unavailable.

	----------------------------------------------------------------------

g:VPars_NextKey~
	Key to trigger the VPars_RepJump() function.
	This key may be redefined any time by setting g:VPars_NextKey and then
	calling VPars_Init() to re-initialize VPars.
	Defaults to <F3>.

g:VPars_AltNext~
	Alternate shortcut to trigger the VPars_RepJump() function.
	This shortcut may be redefined any time by setting g:VPars_AltNext and
	then calling VPars_Init() to re-initialize VPars.
	Setting g:VPars_AltNext to an empty string in this case will disable
	the shortcut.
	Defaults to 'jj'.

g:VPars_AltBegin~
	Alternate shortcut to trigger the VPars_JumpBegin() function.
	This shortcut may be redefined any time by setting g:VPars_AltBegin and
	then calling VPars_Init() to re-initialize VPars.
	Setting g:VPars_AltBegin to an empty string in this case will disable
	the shortcut.
	Defaults to 'jb'.

g:VPars_AltEnd~
	Alternate shortcut to trigger the VPars_JumpEnd() function.
	This shortcut may be redefined any time by setting g:VPars_AltEnd and
	then calling VPars_Init() to re-initialize VPars.
	Setting g:VPars_AltEnd to an empty string in this case will disable
	the shortcut.
	Defaults to 'je'.

g:VPars_AltShow~
	Shortcut to trigger the VPars_Show() function.
	This shortcut may be redefined any time by setting g:VPars_AltShow and
	then calling VPars_Init() to re-initialize VPars.
	Setting g:VPars_AltShow to an empty string in this case will disable
	the shortcut.
	Defaults to 'jo'.

g:VPars_AltInv~
	Shortcut to trigger the VPars_InvalidateBlock() function.
	This shortcut may be redefined any time by setting g:VPars_AltInv and
	then calling VPars_Init() to re-initialize VPars.
	Setting g:VPars_AltInv to an empty string in this case will disable
	the shortcut.
	Defaults to 'ji'.

g:VPars_LocalHeader~
	Redefines the <LocalHeader> initial shortcut sequence used by VPars.
	This must be defined prior to the start of VPars, in a vpars.rc
	initialization file (see:|vpars-user-definitions|).
	Defaults to ','.

	----------------------------------------------------------------------

g:VPars_Verbose~
	Meant for testing. If nonzero, issue warning messages in some cases of
	error.

g:VPars_SkipBlockend~
	If non-zero causes <F3> to automatically advance beyond the text block
	end if no more variables are in there.
	Defaults to 0, which causes the cursor to stop there. To advance in
	this case, the cursor must explicitely be positioned outside the
	dedicated text block.

	----------------------------------------------------------------------

							  *vpars-hooks-enable*
g:VPars_UseHooks~
	Determines how hook functions (|vpars-hooks|) are to be considered.

	Consists of a String composed of 'parse', 'pre' and/or 'post' in any
	order:
	- If it contains 'parse', VPars_PreParseHook() will be called whenever
	  a variable is about to be parsed.
	- If it contains 'pre', VPars_PreVarHook() will be called whenever a
	  variable is about to be substituted.
	- If it contains 'post', VPars_PostVarHook will be called after any
	  variable substitution.

	A missing g:VParse_UseVarHooks or any other value willcause no hook
	functions be called at all.

	May be set at any time before a VPars_NextVar(), VPars_RepJump(), or
	VPars_RepJumpBlock() call.

	No defaults.

g:VPars_HookPrefix~
	Holds the prefix an externally provided hook (|vpars-hooks|) function
	will use.
	Defaults to 'VPars'.

	----------------------------------------------------------------------

g:VPars_MenuName~
	Holds the menu name, VPars will use by default.
	Defaults to "&Variables"

g:VPars_MenuPos~
	Holds a number denoting the relatve position (|menu-priority|) of the
	default VPars menu.
	Defaults to 90.

g:VPars_ShowMenu~
	If non-zero causes VPars to display a GUI menu right on startup.
	Defaults to 0 (i.e. no menu displayed)


------------------------------------------------------------------------------
FUNCTIONS						     *vpars-functions*

INITIALIZATION FUNCTIONS	 *vpars-functions-init* *vpars-init-functions*

VPars_Init()~
	(Re-)initialize some VPars environment and interface settings such as
	the trigger key(default <F3>), etc.

	Will be called at start-up, but can be used by other Vim scripts at
	any time to set up a suiting VPars behavior.

VPars_ResetVar()~
	Used to initialize the buffer local variables.

	Can be used (with caution) by other Vim scripts to force an empty
	state of parsed variables.

	Note:
	- This does not affect the b:StartInsert and b:EndInsert boundary
	  markers of the dedicated text block.

VPars_InvalidateBlock()~
	Resets buffer local variables using VPars_ResetVar() and additionally
	the b:StartInsert, b:EndInsert boundaries and b:AtEndInsert, thus
	invalidating the whole dedicated text block.

	This should be used whenever another text block is about being
	processed, before the end condition of the currently processed
	dedicated text block has been reached.



MENU FUNCTIONS		         *vpars-functions-menu* *vpars-menu-functions*

	  							  *vpars-menu*
VPars_SetupMenu( menuLeader, menuLevel )~
	Makes some VPars functions available through a menu. This will be
	constructed under the caller submitted <menuLeader> submenu entry at
	the <menuLevel> position.

	Example: >

		call VPars_SetupMenu("IDE.substitute\\ variables", "100.50")
	
<	will produce a menu tree like this in the Vim GUI: >

		IDE
			substitute variables
				next variable	   <F3> ,jj
				pause processing	,jp
				resume processing	,jr
				---------------------------
				go block start		,jb
				go block end		,je
				---------------------------
				show block		,jo
				invalidate block	,ji

<	where "IDE" is the (usually already existing) top level menu item. The
	priority level "100" denotes the realtive position of "IDE" in the GUI
	top menu, while the priority ".50" determines the relative position of
	the "substitute variables" submenu entry in the "IDE" menu.

	(For priority levels in Vim menus, see|menu-priority|.)


VPars_DisableMenu( menuLeader )~
	Disables all VPars menu entries.

VPars_EnableMenu( menuLeader )~
	Enables all VPars menu entries.

VPars_RemoveMenu( menuLeader )~
	Removes the whole VPars menu.

VPars_Menu()~
	Toggles an own VPars menu display in the GUI.  Eventually calls
	VPars_MenuSetup() with the values of g:VPars_MenuName and
	g:VPars_MenuPos as parameters.

	This function will be called at startup if the g:VPars_ShowMenu global
	variable had been set to a non-zero value.

	Note:

	- If there is another application-owned menu, the global VPars menu
	  will not be displayed. I.e. application VPars menus always take
	  precedence over the global one.

	- If the global VPars menu had been removed in favour of an
	  application-owned one, it will not automatically be redisplayed once
	  the application has been ceased.  The VPrs_Menu() function must be
	  explicitely called if the global menu is wanted again.

	- This menu can be forced on start-up by setting g:VPars_ShowMenu =
	  1.

	- The name of the menu can be preset in g:VPars_MenuName.

	- The menu position (priority) can be predefined in g:VPars_MenuPos.


PROCESSING FUNCTIONS	*vpars-functions-process* *vpars-processing-functions*

VPars_NextVar( global )~
	Find next variable, delimited by <|..|>

	If <global> is zero, works between b:StartInsert and b:EndInsert lines
	and will turn around to the beginning of the dedicated text block if
	necessary (see:|vpars-substitution-cycle|). Stops at the end of the
	b:EndInsert line, if there are more VPars variables found in this
	dedicated text block.

	If <global> is non-zero, and the cursor is outside the dedicated text
	block, this function will search straight ahead up to the end of the
	current buffer.

	Returns:
	 1 if another variable or a cursor mark was found
	 0 if no more variables were found
	-1 if a delayed variable had been skipped
	-2 if an invalid variable was detected

VPars_RepJump( insMode )~
	Replaces the current variable and jumps to next one.

	Set <insMode> to a non-zero value when called from Vim insert mode.
	Otherwise it must be 0.  This feature is meant to be used from a menu
	or shortcut call and will cause the character under the cursor be
	deleted. This is necessary to get around a column 1 positioning
	problem in Vim insert mode.

	This function is triggered by the <F3> key in Vim normal or insert
	modes.

VPars_RepJumpBlock()~
	Replaces the current variable and jump to next one in the currently
	selected visual block.

	This function is triggered by the <F3> key in Vim visual mode.

	Note:
	- Sets b:StartInsert and b:EndInsert to the visual block boundaries
	  and resets b:AtEndInsert.

VPars_Run( firstLine, lastLine )~
	Main VPars entry point. Prepares a dedicated text block starting at
	<firstLine> and extending up to and including <lastLine>.

	Both <firstLine> or <lastLine> can be zero. In this case the existing
	b:StartInsert or b:EndInsert settings will be used as boundaries.
	This way an existing block can be extended and started as a new one.
	Enters the replacement loop at the beginning of <firstLine>.

	Note:

	- This function will always reset the buffer local variables, thus
	  causing VPars to start processing on a completely fresh block.  If
	  this is not desired, use VPars_RepJump().
	
	- By calling VPars_Run() when b:AtEndInsert does not yet exist, VPars
	  can at any time be forced to reset the internal buffer local
	  processing variables and thus reparse the current variable. (Take
	  care to reposition the cursor in front of the "<|" starting
	  delimiter of this variable.)

	  This can be accomplished through explicitely removing b:AtEndInsert
	  by
>
  		:unlet b:AtEndInsert
<
	  prior to the VPars_Run() call.

VPars_RepList( list )~
	Accepts an array of label-replacement string pairs of the form:

	    [['label_1','replacement_1'], ... ,['label_n','replacement_n']]~

	Scans the text between b:StartInsert and b:EndInsert for every given
	variable with implicit or explicit 'label_i' and replaces it with the
	corresponding 'replacement_i'.

	Note:
	- Explicit labels must be surrounded with ':...:' delimiters.
	
	- The function requires a valid dedicated text block, i.e. the
	  b:StartInsert and b:EndInsert variables must be set prior to the
	  call.

	- No action if the block delimiter marks b:StartInsert and b:EndInsert
	  do not exist or were not properly initialized yet.

	- Processing the variables occurs exactly like in interactive mode.
	  This means in particular that the usual variable hook functions
	  (|vpars-hooks|) will be called if existent and enabled.

	- The cursor will be put at the block start if there was a marked text
	  block.  Otherwise its position will not change.

VPars_Pause()~
	Disables the processing of the current dedicated text block by setting
	the b:AtEndInsert end flag to -1, thus indicating a wait state.

	Note:

	- No action if there is no valid text block.

	- No action if the b:AtEndInsert block end condition has already been
	  set to 1.

VPars_Resume()~
	If there is a valid text block, tries to resume processing at the
	location where the last variable had been replaced.  Mainly used to
	resume processing after a temporary leave to another position in the
	text either by moving the cursor away or pausing with a call to
	VPars_Pause().  Also useful after jumps to the block boundary.

	Note:

	- No action if there is no valid text block.

	- If no valid variable processing could be detected (using the
	  b:VStLine and b:VarStart variables), processing will start at the
	  beginning of the block.


BLOCK JUMP FUNCTIONS	   *vpars-functions-jump* *vpars-block-jump-functions*

VPars_ShowBlock()~
	Visually selects the lines between b:StartInsert and b:EndInsert, thus
	making the current dedicated text block visible.

	Note:

	- This function is by default bound to the ',jo' shortcut.

	- VPars remembers the cursor position before visually selecting the
	  text block.  To continue processing the variables, simply press <F3>
	  again.

VPars_JumpBegin()~
	This puts the cursor at the beginning of the currently defined
	dedicated text block and resets b:AtEndInsert, thus
	re-enabling subsequent VPars variables searches.

	Note:

	- This function is by default bound to the ',jb' shortcut.

VPars_JumpEnd()~
	Causes the cursor be put at the end of the currently defined
	dedicated text block (the end of the b:EndInsert line) and
	sets b:AtEndInsert to 1, thus disabling any processing while
	keeping the b:StartInsert and b:EndInsert boundaries intact.

	Note:

	- This function is by default bound to the ',je' shortcut.

------------------------------------------------------------------------------
PRE AND POST PROCESSING HOOKS					 *vpars-hooks*

A VPars hook function is an externally provided function which can be called
from within VPars.  Figuratively spoken such a function "hooks" from the
outside into the VPars script.  VPars will call such hook functions, if
existing and enabled, in three circumstances:

- immediately before parsing a variable,
- before substituting a variable, and
- after substituting a variable.

That way an external script has enhanced control over what will happen to the
variables, ranging from skipping the variable altogether, through redefinition
according varying environmental needs before the variable is parsed, or
forcing a certain substitution text, up to postprocessing the replaced value,
e.g.  replacing some shorthand code by a lengthy text sequence or even another
set of VPars variables.

There are three hook functions possible, where "<prefix>" denotes a name
prefix given in the g:VPars_HookPrefix global variable, or "VPars" by default.

Note:

- Each hook function runs in the current buffer context and will thus be able
  to easily access the buffer local variables (|vpars-locals|).  Most of the
  passed arguments are for convenience only.

- The available hook functions can be individually enabled before calling
  VPars by setting the g:VPars_UseHooks variable (see:|vpars-hooks-enable|).


				  *vpars-hooks-preparse* *vpars-preparse-hook*

<prefix>_PreParseHook( bufnr, line, varstart, varend )~
	Pre Parse Variable Hook: Will be called immediately before a variable
	is about to be parsed. The variable definition found in this position
	me be altered in any way, even made invalid, deleted, or delayed, as
	VPars still has no idea of it yet.

	The variable to be parsed is located in buffer number <bufnr>, at line
	number <line>, there extending between columns <varstart> and <varend>
	(these are the outer <| ... |> margins).

	Returns:
	Zero to skip this parsing, else non-zero.

	Note:
	- Any change to the text buffer must be reflected in the variable
	  properties (see:|vpars-properties|).

		       *vpars-hook-pre-variable* *vpars-pre-substitution-hook*

<prefix>_PreVarHook( bufnr, line, varstart, varend, label, subst, alt )~
	Preprocess Variable Hook: Will be called before an actual variable
	substitution is about to be done.

	The variable to be substituted is located in buffer number <bufnr>, at
	line number <line>, there extending between columns <varstart> and
	<varend> (these are the outer <| ... |> margins).

	The <label> argument will hold the variable label, and <subst> the
	string to be put in its place, where <alt> will be non-zero if it was
	a selection from the alternatives list.

	Returns:
	Zero to skip this substitution, else non-zero.

		     *vpars-hook-post-variable* *vpars-post-substitution-hook*

<prefix>_PostVarHook( bufnr, line, col, label, subst, alt )~
	Postprocess Variable Hook: Will be called after every substitution,
	but before the substituted text has been processed (e.g. actually have
	been split into multiple lines along '<NL>' marks,
	see:|vpars-substitution-text|).

	The variable substituted recently is located in buffer number <bufnr>,
	at line number <line>.  The substituted text starting at column <col>.
	The <label> argument holds the label of the variable just substituted,
	and <subst> the actual substitution string put in its place, with
	<alt> being non-zero if it was a selection from an alternatives list.

	Note:
	- If the number of lines to be substituted ('<NL>' marks in <subst>)
	  changes due to postprocessing, this must be reflected in the
	  b:VEndLine buffer local variable (see:|vpars-properties|) prior to
	  return.

------------------------------------------------------------------------------
BUFFER LOCAL VARIABLES		 *vpars-locals* *vpars-buffer-local-variables*

VPars uses a number of variables locally to the currently edited buffer on
which it was called. they keep some properties of the currently processed
variable (|vpars-properties|) as well as information on the dedicated text
block (|vpars-text-block|) VPars has to work on (|vpars-boundaries|).


CURRENT VARIABLE PROPERTIES	*vpars-properties* *vpars-variable-properties*

b:VStLine~
	Holds the starting line number of this variable.
	0 after calling VPars_ResetVar().

b:VEndLine~
	Holds the ending line number of this variable
	0 after calling VPars_ResetVar().
	
	Note:
	- This differs from b:VStLine only after multiline replacements.

b:VarStart~
	Holds the start column of this variable (before '<|').
	-1 after calling VPars_ResetVar().

b:VarEnd~
	Holds the end column of this variable (after '|>').
	-1 after calling VPars_ResetVar().

	Note:
	- The b:VarStart and b:VarEnd column numbers are string indexes,
	  starting at 0.


b:VarLabel~
	The label of this variable.
	"" after calling VPars_ResetVar().

	Note:
	- If the variable is explicitely labeled, this will hold the
	  surrounding colons as well: ":explicit label:"

b:ExpLabel~
	Explicit label flag (see:|vpars-explicit-labels|):
	Non-zero if this variable is explicitely labeled, otherwise 0.
	0 after calling VPars_ResetVar().


b:VarSubst~
	Holds the substitution text for this variable.
	"" after calling VPars_ResetVar().
	
	Note:
	- After parsing the variable (on call to a preprocessing hook) this is
	  = the default value in VPars simple variables,
	  = empty in VPars alternatives.

	- After pressing <F3> (on call to a postprocessing hook) this is
	  = the user entered substitution text for VPars simple variables
	  = the selected alternative text in VPars alternatives.

b:SubstEmpty~
	Default text flag for explicitely labeled variables:
	1 if the initial substitution value in an explicitely labeled variable
	was empty, otherwise 0.
	0 after calling VPars_ResetVar().

b:AltSubst~
	Holds an array of substitution values in VPars alternatives.
	[] after calling VPars_ResetVar().

	Note:
	- b:VarSubst is empty after parsing this variable.

b:AltCol~
	Holds an array of substitution column boundaries in VPars alternatives.
	[] after calling VPars_ResetVar().

	Note:
	- The numbers are relative to the start of the value field.

	- If there are no alternatives given, b:AltCol will be empty. This is
	  used internally to discriminate between VPars simple variables and
	  VPars alternatives.


b:VSubstLines~
	The number of lines actually substituted by this replacement.
	This is used internally to adjust the boundaries of the dedicated text
	block, VPars has to work on.
	0 after calling VPars_ResetVar().

TEXT BLOCK BOUNDARIES	      *vpars-boundaries* *vpars-text-block-boundaries*

These buffer local variables have to be externally defined before calling
VPars, except when calling VPars_RepJumpBlock() (see:|vpars-functions|), but
may be altered elsewhere in this script.

The naming is somewhat historical, denoting the last inserted text template
block.

Note:
- These variables will not be affected by the VPars_ResetVar() function.

b:StartInsert~
	Holds the start line number of the dedicated text block.
	0 if no valid text block present.

b:EndInsert~
	Holds the end line number of the dedicated text block.
	0 if no valid text block present.

b:AtEndInsert~
	Flag to signal if VPars has processed all variables in this dedicated
	text block:
	Non-zero if the end of the text block has been reached, 0 otherwise.


OTHER BUFFER LOCALS				   *vpars-other-buffer-locals*

b:VPars_Msg~
	Holds a message text describing most recently encountered error, if
	any. This is the text, VPars will output to the Vim messages area if
	g:VPars_Verbose was set to non-zero.

	Will be empty ("") after calling VPars_ResetVar().

b:VPars_Pos~
	Holds the cursor position in case the dedicated text block has been
	temporarily left.
	
	Currently only used by the VPars_ShowBlock() and VPars_RepJump()
	functions.

	Will be an empty array ([]) after calling VPars_ResetVar().

b:VPars_curMenu~
	Holds the currently used menu heading (see:|vpars-menu|).


==============================================================================
INSTALLING AND CUSTOMIZING			 *vpars-install-and-customize*

VPars has by the author been tested in a Linux environment only.  If there are
issues with other operating system environments (or if you successfully did
VPars run in such), please notify me with a short mail to:
>
	bernd.pol@online.de

------------------------------------------------------------------------------
INSTALLING VPARS					    *vpars-installing*

To install VPars, copy the vpars.zip file into the ~/.vim directory or
equivalent and unzip it there. This will install vpars.vim into the plugins
subdirectory and vpars.txt into the doc subdirectory.

To enable access to this vpars.txt documentation (you currently read) start
Vim and issue >

	:helptags ~/.vim/doc

vpars.txt should then be listed in the LOCAL ADDITIONS section of the Vim main
help (issue :help, and the scroll down to the end).

To access VPars help >

	:help vpars

will display the CONTENTS section of this help, and >

	:help vpars-index

will get you to the INDEX section (which collects all VPars help targets).

------------------------------------------------------------------------------
USER DEFINITIONS		    *vpars-user-definitions* *vpars-init-file*

The behavior of VPars is defined by some global variables (|vpars-globals|).
Preferred non-default settings can be put into a >

	vpars.rc

file. VPars will look for this file along the Vim|'runtimepath'|. Usually this
file will be put into the user's Vim directory ($HOME/.vim on Unix systems). 

Note:
- To inhibit loading the VPars script altogether, let g:vpars_vim=0 in your
  startup script (see|vpars-inhibit|).

------------------------------------------------------------------------------
REDEFINING THE TRIGGER KEY		       *vpars-key* *vpars-redefine-F3*

By default, VPars uses the <F3> function key to interactivey substitute a
variable and find the next.  This key can be redefined at any time by setting
the g:VPars_NextKey variable and then calling the VPars_Init() function.

Example:
	To use the CTRL-J (or: <NL>) key instead of <F3> issue the following
	on the Vim command line: >

		:let g:VPars_NextKey="<C-J>"
		:call VPars_Init()

VPars will unmap the previously used trigger key and map the key defined in
g:VPars_NextKey to the VPars_RepJump() and VPars_RepJumpBlock() functions.

To get the default back unlet thethe g:VPars_NextKey variable and then call
VPars_Init(): >

		:unlet g:VPars_NextKey
		:call VPars_Init()

Will unmap any trigger key redefintion and map <F3> back to VPars_RepJump()
and VPars_RepJumpBlock().

------------------------------------------------------------------------------
ALTERNATE SHORTCUT KEYS		  *vpars-alternate-keys* *vpars-shortcut-keys*

Mainly in order to give an external script more control over VPars, there is a
set of alternate shortcut keys provided which are initially mapped as such: >

	jj	triggers the next variable search (like <F3>)
<		(|vpars-substitution|) >

	jp	pause the VPars processing loop.
<		(|vpars-pause|) >
	jr	resume processing the VPars loop
<		(|vpars-resume|) >

	jb	jumps to the beginning of the dedicated text block
		and re-enables the search
<		(|vpars-jump-begin|) >
	je	jumps to the end of the dedicated text block
		and disables further seaches, even if there are
		some variables still unprocessed
<		(|vpars-jump-end|) >

	jo	visually selects the dedicated text block
<		(|vpars-show-block|) >

	ji	invalidates the dedicated text block
<		(|vpars-invalidate-block|)

Note:

- Take caution when using these shortcuts.  Other than the menu entries these
  shortcuts will always be enabled, even in situations where they do not
  apply.  Although VPars does do some validity checks, proper function cannot
  be guaranteed in all situations.

						    *vpars-shortcut-remapping*
The user or some other script can remap or even unmap these shortcuts by means
of setting some global variables and subsequently re-initializing VPars
through a VPars_Init() call: >

	g:VPars_AltNext		remaps the 'jj' shortcut
	g:Vpars_AltPause	remaps the 'jp' shortcut
	g:VPars_AltResume	remaps the 'jr' shortcut
	g:VPars_AltBegin	remaps the 'jb' shortcut
	g:VPars_AltEnd		remaps the 'je' shortcut
	g:VPars_AltShow		remaps the 'jo' shortcut
	g:VPars_AltInv		remaps the 'ji' shortcut

Setting any of these globals to an empty string will completely unmap the
shortcut, thus making this alternate shortcut function access unavailable.

Note:
- VPars will always unmap the previous mapping before mapping the function
  call to the new key definition.

- The shortcuts are preceded by the|<LocalLeader>|which defaults to a comma.
  It can be redefined using the >
 	g:VPars_LocalLeader 
< variable. Its actual value is kept in the >
	s:LL
< script variable.

------------------------------------------------------------------------------
INCLUDING A VPARS MENU				 	  *vpars-include-menu*

Although VPars was designed to be keyboard controlled, an external script can
include some GUI menu entries at a desired place.  This is controlled via
several VPars functions.

The user can force VPars to show a default GUI menu at startup by defining
both of these global variables in the vpars.rc initialization file (or the
global vimrc initialization file).

g:VPars_MenuName~
	Holds the menu name, VPars will use by default.
	Defaults to "&Variables"

g:VPars_MenuPos~
	Holds a number denoting the relatve position (|menu-priority|) of the
	default VPars menu.
	Defaults to 90.

g:VPars_ShowMenu~
	If non-zero causes VPars to display a GUI menu right on startup.
	Defaults to 0 (i.e. no menu displayed)


In general, these features allow an outside script to insert, remove, or
disable/enable in a caller supplied menu a submenu like this: >

	next variable	   <F3> ,jj
	pause processing	,jp
	resume processing	,jr
	---------------------------
	go block begin		,jb
	go block end		,je
	---------------------------
	show block		,jo
	invalidate block	,ji

with the menu entries being enabled or disabled according to the current
processing situation.

For more detail, see|vpars-menu|.

------------------------------------------------------------------------------
ADVANCING OVER THE BLOCK END				    *vpars-skip-atend*

VPars will by default stop at the end of the dedicated text block once all
variables have been processed in there.  To process any other VPars variable
beyond this position, the user must explicitely put the cursor of the
dedicated text block and the issue <F3> again.  This behavior can be changed
by setting the g:VPars_SkipBlockend to a non-zero value: >

	:let g:VPars_SkipBlockend=1

will cause VPars to find some VPars variable beyond the dedicated text after
all variable had been processed in there without the need to manually
reposition the cursor. >

	:let g:VPars_SkipBlockend=0
or >
	:unlet g:VPars_SkipBlockend

will switch back to the default behaviour.

Note:

- VPars will stop at the end of the dedicated text block in any case to signal
  this condition to the user. By default it will however remain there through
  subsequent <F3> keypresses, while the altered behavior will cause <F3> to
  search further.

- Once the dedicated text block has been left either manually or after
  changing the default behavior, The b:StartInsert and b:EndInsert variables
  will both be reset to 0, thereby invalidating the dedicated text block.

------------------------------------------------------------------------------
USING VERBOSE MODE					       *vpars-verbose*

VPars can detect several error conditions in the dedicated text block.
Usually they will go quietly, but for debugging purposes VPars can issue
warning messages in the Vim messages area.  This verbose mode is enabled
through the g:VPars_Verbose variable. >

	:let g:VPars_Verbose=1

(or any other non-zero value) will cause error messages be displayed. >

	:let g:VPars_Verbose=0
or >
	:unlet g:VPars_Verbose

will cause the default quiet behaviour again.

Note:

- This verbose mode is not perfect as Vim wil use the same messages area for
  other purposes as well, thereby in some cases overwriting the warning before
  it might have been noticed. The Vim >

	:messages
~
  command will however redisplay the most recently issued warnings again.

==============================================================================
KNOWN PROBLEMS						      *vpars-problems*

There is no software whithout problems or open wishes.  The following
summarizes which bugs were known at this release and what would be desirable
to implement else (yet possibly never would ;-) ).

Do not hesitate to punch the author for any problem biting you in using VPars.
Mail to:
>
	bernd.pol@online.de
<
------------------------------------------------------------------------------
BUGS								  *vpars-bugs*

- When multiple lines were inserted and the cursor left the position
  prematurely (i.e. before the next <F3> keypress) to another line inside or
  outside the block, the b:EndInsert block end boundary will be computed
  (sometimes extremely) false at the next <F3>.

- A variable starting at the left boundary of the first text block line is not
  recognized.

- When a visual block was selected fromout insert mode before pressing <F3>,
  the cursor is left inside the '<|' leading delimiter of the first variable.
  (A mere nuisance only, the user can go on using the default value for
  replacement by simply pressing <F3> as usual.)

------------------------------------------------------------------------------
TODOS								 *vpars-todos*

- VPars has as yet been tested on Linux only.  Any experiences with other
  systems, especially Windows-based implementations are welcome.

- Allow full fledged VPars variables in substitution texts.  (Beyond the
  "programmed variable" mechanism.)

- Do not use hard coded '<| .. | .. |: .. :|>' delimiters.  (Might however
  never be done as it probably will considerably complicate the script.)

- Map/Unmap shortcuts like the menu entries are adapted to different
  situations.

==============================================================================
THANKS								*vpars-thanks*

VPars is based on quite a lot of ideas found elsewhere. Most notably I would
like to thank:

Felix Ingram~
	for developing the snippetsEmu.vim (Vim script # 1318) script from
	which the basic ideas for a powerful, yet basically simple variable
	substitution mechanism came.

Fritz Mehner~
	for the CSupport c.vim (Vim script # 213) script which served as a
	powerful source of concepts and as testbed as well to further develop
	the VPars variable substitution mechanisms up to the current state.
	
Igor Prischepoff~
	for his thorough testing efforts.

==============================================================================
INDEX								 *vpars-index*

|vpars|

|vpars-alternate-keys|			|vpars-alternatives|
|vpars-alternatives-altered|		|vpars-alternatives-delimiter|
|vpars-alternatives-empty|		|vpars-alternatives-escaped-bars|
|vpars-alternatives-example|		|vpars-alternatives-non-repeating|
|vpars-alternatives-restrictions|	|vpars-alternatives-syntax|
|vpars-api|				|vpars-atend|
|vpars-automatic-substitution|

|vpars-basic|				|vpars-batch|
|vpars-batch-example|			|vpars-batch-syntax|
|vpars-beyond-cycle|			|vpars-block-end-condition|
|vpars-block-jump-functions|		|vpars-boundaries|
|vpars-buffer-local-variables|		|vpars-bugs|

|vpars-commons|				|vpars-contents|
|vpars-cursor|				|vpars-cursor-in-delimiters|
|vpars-cursor-role|

|vpars-dedicated-text|			|vpars-default|
|vpars-default-substitution|		|vpars-defininitions|
|vpars-delay-escape-dot|		|vpars-delaying-variables|
|vpars-delete|				|vpars-delimiters|

|vpars-empty-alternative|		|vpars-empty-substitution|
|vpars-example|				|vpars-explicit-colons|
|vpars-explicit-labels|			|vpars-explicit-reparse|

|vpars-functions|			|vpars-functions-init|
|vpars-functions-jump|			|vpars-functions-menu|
|vpars-functions-process|

|vpars-global-mode|			|vpars-globals|

|vpars-hook-post-variable|		|vpars-hook-pre-variable|
|vpars-hooks|				|vpars-hooks-enable|
|vpars-hooks-preparse|			|vpars-install-and-customize|

|vpars-include-menu|			|vpars-inhibit|
|vpars-init-file|			|vpars-init-functions|
|vpars-installing|			|vpars-interface|
|vpars-intro|				|vpars-intro-example|
|vpars-invalidate-block|

|vpars-jump-begin|			|vpars-jump-end|

|vpars-key|

|vpars-label|				|vpars-leave-temporarily|
|vpars-leave-to-another|		|vpars-left-delimiter|
|vpars-left-explicit-label|		|vpars-locals|

|vpars-menu|				|vpars-menu-functions|
|vpars-modes|				|vpars-multiple-lines|

|vpars-NL-mark|				|vpars-normal-mode|

|vpars-other-buffer-locals|

|vpars-pause|
|vpars-post-substitution-hook|		|vpars-pre-substitution-hook|
|vpars-precedence-of-explicit-labels|	|vpars-preparse-hook|
|vpars-principles|			|vpars-problems|
|vpars-programmed-variables|		|vpars-processing-functions|
|vpars-properties|

|vpars-redefine-F3|			|vpars-remove-simple-variable|
|vpars-replace-all-simple-vars|		|vpars-restrictions|
|vpars-resume|				|vpars-right-delimiter|
|vpars-right-explicit-label|		|vpars-role-of-the-cursor|

|vpars-shortcut-keys|			|vpars-shortcut-remapping|
|vpars-show-block|			|vpars-simple-var-delete|
|vpars-simple-variables|		|vpars-skip-atend|
|vpars-start-functions|			|vpars-structure|
|vpars-substitute-multilines|		|vpars-substitution|
|vpars-substitution-alternative|	|vpars-substitution-block|
|vpars-substitution-cycle|		|vpars-substitution-delayed|
|vpars-substitution-explicit|		|vpars-substitution-list|
|vpars-substitution-simple|		|vpars-substitution-text|
|vpars-suppress-delays|

|vpars-terms|				|vpars-text-block|
|vpars-text-block-boundaries|		|vpars-thanks|
|vpars-types|				|vpars-todos|

|vpars-user-definitions|

|vpars-variable-properties|		|vpars-variables|
|vpars-variables-order|			|vpars-variables-order-delay|
|vpars-variables-order-example|		|vpars-verbose|

==============================================================================
  vim:enc=utf-8:tw=78:ts=8:ft=help:norl:
